using ArkSaveEditor;
using ArkSaveEditor.Entities;
using ArkSaveEditor.Entities.LowLevel.AutoGeneratedClasses;
using ArkSaveEditor.Entities.LowLevel.DotArk;
using ArkSaveEditor.Entities.LowLevel.DotArk.ArkProperties;
using ArkSaveEditor.Entities.LowLevel.Inline;
using ArkSaveEditor.Entities.LowLevel.Inline.InlineProperties;
using ArkSaveEditor.World;
using EchoReader.Exceptions;
using EchoReader.Helpers;
using EchoReader.ServerJobs;
using LibDeltaSystem.Db.Content;
using LibDeltaSystem.Db.System;
using LibDeltaSystem.Entities;
using MongoDB.Bson;
using MongoDB.Driver;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using static ArkSaveEditor.Entities.LowLevel.Inline.InlineProperties.InlineStructProperty;

namespace EchoReader.Entities
{
    /// <summary>
    /// Represents an Ark server
    /// </summary>
    public class ArkServer
    {
        /// <summary>
        /// The ARK server ID
        /// </summary>
        public string id;

        /// <summary>
        /// Content uploaded
        /// </summary>
        public List<ArkUploadedFile> files;

        /// <summary>
        /// Used for version control
        /// </summary>
        public uint revision_id { get; set; }

        /// <summary>
        /// Saves and changes to disk
        /// </summary>
        public void Save()
        {
            //Write serilaized
            ArkServerSerialized ser = new ArkServerSerialized
            {
                files = files,
                _id = id,
                revision_id = revision_id
            };

            //Save
            Program.servers_collection.Upsert(ser);
        }

        /// <summary>
        /// Loads all settings from disk
        /// </summary>
        public void Load(ArkServerSerialized ser)
        {
            id = ser._id;
            files = ser.files;
            revision_id = ser.revision_id;
        }

        /// <summary>
        /// Returns a file's metadata. If it doesn't exist, this returns null
        /// </summary>
        /// <param name="type"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        public ArkUploadedFile GetFileMeta(ArkUploadedFileType type, string name)
        {
            //Try to find
            var results = files.Where(x => x.type == type && x.name == name);
            if (results.Count() == 0)
                return null;
            return results.First();
        }

        /// <summary>
        /// Obtains a file stream for a file. If the file doesn't exist, this will throw an exception.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        public async Task<Stream> GetRequiredFileStream(ArkUploadedFileType type, string name)
        {
            ArkUploadedFile meta = GetFileMeta(type, name);
            if (meta == null)
                throw new MissingRequiredFileException(name, type);
            return await GetFileStream(meta);
        }

        /// <summary>
        /// Gets the decompressed file stream
        /// </summary>
        /// <param name="f"></param>
        /// <returns></returns>
        public static async Task<Stream> GetFileStream(ArkUploadedFile f)
        {
            //Open GZIP stream
            TempFileStream ts = TempFileStream.OpenTemp();
            using (FileStream fs = new FileStream(Program.config.content_uploads_path + f.token, FileMode.Open, FileAccess.Read))
            {
                using (GZipStream gz = new GZipStream(fs, CompressionMode.Decompress))
                    await gz.CopyToAsync(ts);
            }
            ts.Position = 0;
            return ts;
        }

        /// <summary>
        /// Uploads a file and replaces any existing file
        /// </summary>
        /// <param name="type">The type of the file.</param>
        /// <param name="name">The name of the file.</param>
        /// <param name="compressed">The data for this file.</param>
        /// <returns></returns>
        public async Task<ArkUploadedFile> PutFile(ArkUploadedFileType type, string name, Stream compressed)
        {
            //Generate a new token
            string token = Program.GenerateRandomString(32);
            while(File.Exists(Program.config.content_uploads_path+token))
                token = Program.GenerateRandomString(32);

            //Write this to disk
            long size;
            using (FileStream fs = new FileStream(Program.config.content_uploads_path + token, FileMode.Create))
            {
                await compressed.CopyToAsync(fs);
                size = fs.Length;
            }

            //If there is already a file with this name, get it and remove it
            ArkUploadedFile file = GetFileMeta(type, name);
            if(file != null)
            {
                File.Delete(Program.config.content_uploads_path + file.token);
                files.Remove(file);
            }

            //Create a new file entry
            file = new ArkUploadedFile
            {
                name = name,
                type = type,
                time_utc = DateTime.UtcNow.Ticks,
                token = token,
                compressed_size = size
            };

            //Obtain SHA1
            using (Stream data = await GetFileStream(file))
            using (SHA1Managed sha1 = new SHA1Managed())
            {
                byte[] hashBytes = sha1.ComputeHash(data);
                file.sha1 = string.Concat(hashBytes.Select(b => b.ToString("x2")));
                file.size = data.Length;
            }

            //Save
            files.Add(file);
            Save();

            return file;
        }

        /// <summary>
        /// Cleans old revisions from the database.
        /// </summary>
        /// <returns></returns>
        public async Task CleanOldRevisions()
        {
            {
                var filterBuilder = Builders<DbDino>.Filter;
                var filter = filterBuilder.Eq("server_id", id) & filterBuilder.Lt("revision_id", revision_id);
                await Program.conn.content_dinos.DeleteManyAsync(filter);
            }
            {
                var filterBuilder = Builders<DbItem>.Filter;
                var filter = filterBuilder.Eq("server_id", id) & filterBuilder.Lt("revision_id", revision_id);
                await Program.conn.content_items.DeleteManyAsync(filter);
            }
        }

        /// <summary>
        /// Updates data
        /// </summary>
        /// <returns></returns>
        public async Task ProcessData()
        {
            //First, confirm we have required files
            Stream arkSave = await GetRequiredFileStream(ArkUploadedFileType.ArkSave, "game");
            Stream gameIni = await GetRequiredFileStream(ArkUploadedFileType.GameConfigINI, "Game.ini");
            Stream gameUserSettingsIni = await GetRequiredFileStream(ArkUploadedFileType.GameConfigINI, "GameUserSettings.ini");

            //Find existing player profiles for later
            var oldProfiles = await GetPlayerProfilesAsync();

            //Increase revision ID 
            revision_id++;

            //Start streaming the .ark file
            ArkSaveEditor.Deserializer.DotArk.DotArkDeserializer dotArkDs;

            //Create ProcessClassnameMeta for processing the .ark file
            dotArkDs = new ArkSaveEditor.Deserializer.DotArk.DotArkDeserializer();
            JobSyncDinos syncDinos = new JobSyncDinos(this, dotArkDs);
            JobSyncStructures syncStructures = new JobSyncStructures(this, dotArkDs);

            //Create
            arkSave.Position = 0;
            dotArkDs.OpenArkFile(new IOMemoryStream(arkSave, true), (DotArkGameObject obj, object d) =>
            {
                //We're going to determine what this is.
                string classnameOriginal = obj.classname.classname;
                string classname = classnameOriginal;
                if (classname.EndsWith("_C"))
                    classname = classname.Substring(classname.Length - 2);

                //Decide
                if (Enum.TryParse<DinoClasses>(classnameOriginal, out DinoClasses dinoClass))
                {
                    //This is a dinosaur.
                    return syncDinos.RunOne;
                }
                if(ArkImports.GetStructureDisplayMetadataByClassname(classnameOriginal) != null)
                {
                    //This is a structure
                    return syncStructures.RunOne;
                }

                //Not found
                return null;
            }, null);

            //Now, add embedded files
            foreach(var f in files)
            {
                if (f.type == ArkUploadedFileType.ArkTribe)
                    await ProcessTribeFile(await GetFileStream(f));
                if (f.type == ArkUploadedFileType.ArkProfile)
                    await ProcessPlayerFile(await GetFileStream(f));
            }

            //Finish sync requests
            await syncDinos.End();
            await syncStructures.End();

            //We'll now update the server in the database. Download it.
            DbServer ser = await Program.conn.GetServerByIdAsync(id);
            ser.revision_id = revision_id;
            ser.latest_server_map = dotArkDs.binaryDataNames[0];
            ser.latest_server_map_name = ser.latest_server_map;
            ser.has_server_report = true;
            ser.latest_server_time = dotArkDs.ark.gameTime;
            await ser.UpdateAsync();

            //Save
            Save();

            //Close all 
            arkSave.Close();
            gameIni.Close();
            gameUserSettingsIni.Close();

            //Dispose all
            arkSave.Dispose();
            gameIni.Dispose();
            gameUserSettingsIni.Dispose();

            //Send events for joining/leaving
            await SendPlayerJoinEvents(oldProfiles);

            //Clean up old revisions
            await CleanOldRevisions();
        }

        private async Task<List<DbPlayerProfile>> GetPlayerProfilesAsync()
        {
            var filterBuilder = Builders<DbPlayerProfile>.Filter;
            var filter = filterBuilder.Eq("server_id", id);
            var results = await (await Program.conn.content_player_profiles.FindAsync(filter)).ToListAsync();
            return results;
        }

        /// <summary>
        /// Sends events to the gateway that a new player was added.
        /// </summary>
        /// <returns></returns>
        private async Task SendPlayerJoinEvents(List<DbPlayerProfile> oldResults)
        {
            //First, find new and old player profile lists
            var newResults = await GetPlayerProfilesAsync();

            //Now, compare to find new players
            var newPlayers = newResults.Where(x => oldResults.Where(y => y.steam_id == x.steam_id).Count() == 0).ToArray();

            //Now, send events for these players
            foreach(var p in newPlayers)
            {
                //A user account may or may not exist. If it does exist, use it
                DbUser user = await Program.conn.GetUserBySteamIdAsync(p.steam_id);
                if (user == null)
                    continue;

                //Send the gateway a refresh event
                Program.gateway.SendRefreshIndex("USER", user.id);

                //Send an event for adding a server to this user
                Program.gateway.SendMessageToUserWithId(new ArkWebMapGatewayClient.Messages.MessageOnServerListUpdate
                {
                    time = DateTime.UtcNow,
                    headers = new Dictionary<string, string>(),
                    opcode = ArkWebMapGatewayClient.GatewayMessageOpcode.OnServerListUpdate
                }, user.id);
            }
        }

        /// <summary>
        /// Processes the tribe file
        /// </summary>
        private async Task ProcessTribeFile(Stream f)
        {
            //Open inline file
            var indes = new ArkSaveEditor.Deserializer.Inline.InlineFileDeserializer();
            var source = indes.ReadInlineFile(f);

            //Grab tribe data struct.
            var tribeData = (InlineStructProperty)source.props[0];
            var tribeDataStruct = (InlineStructProperty.ArkStructInlineProps)tribeData.data;

            //Grab data
            DbTribe output = new DbTribe
            {
                server_id = id,
            };
            InlineProperty temp;
            temp = InlineGetPropertyByName("TribeName", tribeDataStruct);
            output.tribe_name = ((InlineStrProperty)temp).value;

            temp = InlineGetPropertyByName("TribeID", tribeDataStruct);
            output.tribe_id = ((InlineIntProperty)temp).value;
            output.token = output.tribe_id.ToString();

            temp = InlineGetPropertyByName("OwnerPlayerDataID", tribeDataStruct);
            if (temp != null)
                output.tribe_owner = ((InlineUInt32Property)temp).value;
            else
                output.tribe_owner = 0;

            //Close
            f.Close();
            f.Dispose();

            //Update or insert
            var filterBuilder = Builders<DbTribe>.Filter;
            var filter = filterBuilder.Eq("server_id", id) & filterBuilder.Eq("tribe_id", output.tribe_id);
            await Program.conn.content_tribes.FindOneAndReplaceAsync<DbTribe>(filter, output, new FindOneAndReplaceOptions<DbTribe, DbTribe>
            {
                IsUpsert = true,
                ReturnDocument = ReturnDocument.After
            });
        }

        /// <summary>
        /// Processes the tribe file
        /// </summary>
        private async Task ProcessPlayerFile(Stream f)
        {
            //Open inline file
            var indes = new ArkSaveEditor.Deserializer.Inline.InlineFileDeserializer();
            var source = indes.ReadInlineFile(f);

            //Grab tribe player struct.
            InlineStructProperty playerDataStruct = (InlineStructProperty)source.props.Find(x => x.name.CompareNameTo("MyData"));
            ArkStructInlineProps playerData = (ArkStructInlineProps)playerDataStruct.data;

            //Grab data
            DbPlayerProfile output = new DbPlayerProfile
            { 
                server_id = id,
            };

            //Read basics
            output.name = ((InlineStrProperty)playerData.props.Find(x => x.name.CompareNameTo("PlayerName"))).value;
            output.ark_id = ((InlineUInt64Property)playerData.props.Find(x => x.name.CompareNameTo("PlayerDataID"))).value;

            //Steam ID is read below
            output.tribe_id = -1;
            try
            {
                output.tribe_id = ((InlineIntProperty)playerData.props.Find(x => x.name.CompareNameTo("TribeID"))).value;
            }
            catch { }

            //in-game name is read below
            InlineStructProperty playerStats = (InlineStructProperty)(playerData.props.Where(x => x.name.CompareNameTo("MyPlayerCharacterConfig")).ToArray()[0]);
            output.ig_name = ((InlineStrProperty)(((ArkStructInlineProps)playerStats.data).props.Where(x => x.name.CompareNameTo("PlayerCharacterName")).ToArray()[0])).value;

            //Read Steam ID
            InlineStructProperty steamStruct = (InlineStructProperty)playerData.props.Find(x => x.name.CompareNameTo("UniqueID"));
            ArkStructUniqueNetId steamData = (ArkStructUniqueNetId)steamStruct.data;
            output.steam_id = steamData.netId;
            output.token = output.steam_id;

            //Close
            f.Close();
            f.Dispose();

            //Update or insert
            var filterBuilder = Builders<DbPlayerProfile>.Filter;
            var filter = filterBuilder.Eq("server_id", id) & filterBuilder.Eq("steam_id", output.steam_id);
            await Program.conn.content_player_profiles.FindOneAndReplaceAsync<DbPlayerProfile>(filter, output, new FindOneAndReplaceOptions<DbPlayerProfile, DbPlayerProfile>
            {
                IsUpsert = true,
                ReturnDocument = ReturnDocument.After
            });
        }

        /// <summary>
        /// Helper class
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private InlineProperty InlineGetPropertyByName(string name, InlineStructProperty.ArkStructInlineProps container)
        {
            var data = container.props.Where(x => x.name.CompareNameTo(name)).ToArray();
            if (data.Length == 1)
                return data[0];
            return null;
        }
    }
}
