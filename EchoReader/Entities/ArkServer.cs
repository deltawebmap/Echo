using ArkSaveEditor.Entities;
using ArkSaveEditor.Entities.LowLevel.AutoGeneratedClasses;
using ArkSaveEditor.Entities.LowLevel.DotArk;
using ArkSaveEditor.Entities.LowLevel.DotArk.ArkProperties;
using ArkSaveEditor.Entities.LowLevel.Inline;
using ArkSaveEditor.Entities.LowLevel.Inline.InlineProperties;
using ArkSaveEditor.World;
using EchoReader.Exceptions;
using EchoReader.Helpers;
using LibDeltaSystem.Db.Content;
using LibDeltaSystem.Db.System;
using MongoDB.Driver;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using static ArkSaveEditor.Entities.LowLevel.Inline.InlineProperties.InlineStructProperty;

namespace EchoReader.Entities
{
    /// <summary>
    /// Represents an Ark server
    /// </summary>
    public class ArkServer
    {
        /// <summary>
        /// The ARK server ID
        /// </summary>
        public string id;

        /// <summary>
        /// Content uploaded
        /// </summary>
        public List<ArkUploadedFile> files;

        /// <summary>
        /// Used for version control
        /// </summary>
        public uint revision_id { get; set; }

        /// <summary>
        /// Saves and changes to disk
        /// </summary>
        public void Save()
        {
            //Write serilaized
            ArkServerSerialized ser = new ArkServerSerialized
            {
                files = files,
                _id = id,
                revision_id = revision_id
            };

            //Save
            Program.servers_collection.Upsert(ser);
        }

        /// <summary>
        /// Loads all settings from disk
        /// </summary>
        public void Load(ArkServerSerialized ser)
        {
            id = ser._id;
            files = ser.files;
            revision_id = ser.revision_id;
        }

        /// <summary>
        /// Returns a file's metadata. If it doesn't exist, this returns null
        /// </summary>
        /// <param name="type"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        public ArkUploadedFile GetFileMeta(ArkUploadedFileType type, string name)
        {
            //Try to find
            var results = files.Where(x => x.type == type && x.name == name);
            if (results.Count() == 0)
                return null;
            return results.First();
        }

        /// <summary>
        /// Obtains a file stream for a file. If the file doesn't exist, this will throw an exception.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        public async Task<Stream> GetRequiredFileStream(ArkUploadedFileType type, string name)
        {
            ArkUploadedFile meta = GetFileMeta(type, name);
            if (meta == null)
                throw new MissingRequiredFileException(name, type);
            return await GetFileStream(meta);
        }

        /// <summary>
        /// Gets the decompressed file stream
        /// </summary>
        /// <param name="f"></param>
        /// <returns></returns>
        public static async Task<Stream> GetFileStream(ArkUploadedFile f)
        {
            //Open GZIP stream
            TempFileStream ts = TempFileStream.OpenTemp();
            using (FileStream fs = new FileStream(Program.config.content_uploads_path + f.token, FileMode.Open, FileAccess.Read))
            {
                using (GZipStream gz = new GZipStream(fs, CompressionMode.Decompress))
                    await gz.CopyToAsync(ts);
            }
            ts.Position = 0;
            return ts;
        }

        /// <summary>
        /// Uploads a file and replaces any existing file
        /// </summary>
        /// <param name="type">The type of the file.</param>
        /// <param name="name">The name of the file.</param>
        /// <param name="compressed">The data for this file.</param>
        /// <returns></returns>
        public async Task<ArkUploadedFile> PutFile(ArkUploadedFileType type, string name, Stream compressed)
        {
            //Generate a new token
            string token = Program.GenerateRandomString(32);
            while(File.Exists(Program.config.content_uploads_path+token))
                token = Program.GenerateRandomString(32);

            //Write this to disk
            long size;
            using (FileStream fs = new FileStream(Program.config.content_uploads_path + token, FileMode.Create))
            {
                await compressed.CopyToAsync(fs);
                size = fs.Length;
            }

            //If there is already a file with this name, get it and remove it
            ArkUploadedFile file = GetFileMeta(type, name);
            if(file != null)
            {
                File.Delete(Program.config.content_uploads_path + file.token);
                files.Remove(file);
            }

            //Create a new file entry
            file = new ArkUploadedFile
            {
                name = name,
                type = type,
                time_utc = DateTime.UtcNow.Ticks,
                token = token,
                compressed_size = size
            };

            //Obtain SHA1
            using (Stream data = await GetFileStream(file))
            using (SHA1Managed sha1 = new SHA1Managed())
            {
                byte[] hashBytes = sha1.ComputeHash(data);
                file.sha1 = string.Concat(hashBytes.Select(b => b.ToString("x2")));
                file.size = data.Length;
            }

            //Save
            files.Add(file);
            Save();

            return file;
        }

        /// <summary>
        /// Cleans old revisions from the database.
        /// </summary>
        /// <returns></returns>
        public async Task CleanOldRevisions()
        {
            {
                var filterBuilder = Builders<DbDino>.Filter;
                var filter = filterBuilder.Eq("server_id", id) & filterBuilder.Lt("revision_id", revision_id);
                await Program.conn.content_dinos.DeleteManyAsync(filter);
            }
            {
                var filterBuilder = Builders<DbItem>.Filter;
                var filter = filterBuilder.Eq("server_id", id) & filterBuilder.Lt("revision_id", revision_id);
                await Program.conn.content_items.DeleteManyAsync(filter);
            }
        }

        /// <summary>
        /// Updates data
        /// </summary>
        /// <returns></returns>
        public async Task ProcessData()
        {
            //First, confirm we have required files
            Stream arkSave = await GetRequiredFileStream(ArkUploadedFileType.ArkSave, "game");
            Stream gameIni = await GetRequiredFileStream(ArkUploadedFileType.GameConfigINI, "Game.ini");
            Stream gameUserSettingsIni = await GetRequiredFileStream(ArkUploadedFileType.GameConfigINI, "GameUserSettings.ini");

            //Increase revision ID 
            revision_id++;

            //Start streaming the .ark file
            ArkSaveEditor.Deserializer.DotArk.DotArkDeserializer dotArkDs;

            //Create
            arkSave.Position = 0;
            dotArkDs = new ArkSaveEditor.Deserializer.DotArk.DotArkDeserializer();
            dotArkDs.OpenArkFile(new IOMemoryStream(arkSave, true), (DotArkGameObject obj, object d) =>
            {
                //We're going to determine what this is.
                string classname = obj.classname.classname;
                if (Enum.TryParse<DinoClasses>(classname, out DinoClasses dinoClass))
                {
                    //This is a dinosaur.
                    return ProcessDino;
                }

                //Not found
                return null;
            }, dotArkDs);

            //Now, add embedded files
            foreach(var f in files)
            {
                if (f.type == ArkUploadedFileType.ArkTribe)
                    await ProcessTribeFile(await GetFileStream(f));
                if (f.type == ArkUploadedFileType.ArkProfile)
                    await ProcessPlayerFile(await GetFileStream(f));
            }

            //We'll now update the server in the database. Download it.
            DbServer ser = await Program.conn.GetServerByIdAsync(id);
            ser.revision_id = revision_id;
            ser.latest_server_map = dotArkDs.binaryDataNames[0];
            ser.latest_server_map_name = ser.latest_server_map;
            ser.has_server_report = true;
            ser.latest_server_time = dotArkDs.ark.gameTime;
            await ser.UpdateAsync();

            //Save
            Save();

            //Close all 
            arkSave.Close();
            gameIni.Close();
            gameUserSettingsIni.Close();

            //Dispose all
            arkSave.Dispose();
            gameIni.Dispose();
            gameUserSettingsIni.Dispose();

            //Clean up old revisions
            await CleanOldRevisions();
        }

        /// <summary>
        /// Processes the tribe file
        /// </summary>
        private async Task ProcessTribeFile(Stream f)
        {
            //Open inline file
            var indes = new ArkSaveEditor.Deserializer.Inline.InlineFileDeserializer();
            var source = indes.ReadInlineFile(f);

            //Grab tribe data struct.
            var tribeData = (InlineStructProperty)source.props[0];
            var tribeDataStruct = (InlineStructProperty.ArkStructInlineProps)tribeData.data;

            //Grab data
            DbTribe output = new DbTribe
            {
                revision_id = revision_id,
                server_id = id,
            };
            InlineProperty temp;
            temp = InlineGetPropertyByName("TribeName", tribeDataStruct);
            output.tribe_name = ((InlineStrProperty)temp).value;

            temp = InlineGetPropertyByName("TribeID", tribeDataStruct);
            output.tribe_id = ((InlineIntProperty)temp).value;

            temp = InlineGetPropertyByName("OwnerPlayerDataID", tribeDataStruct);
            if (temp != null)
                output.tribe_owner = ((InlineUInt32Property)temp).value;
            else
                output.tribe_owner = 0;

            //Close
            f.Close();
            f.Dispose();

            //Update or insert
            var filterBuilder = Builders<DbTribe>.Filter;
            var filter = filterBuilder.Eq("server_id", id) & filterBuilder.Eq("tribe_id", output.tribe_id);
            await Program.conn.content_tribes.FindOneAndReplaceAsync<DbTribe>(filter, output, new FindOneAndReplaceOptions<DbTribe, DbTribe>
            {
                IsUpsert = true,
                ReturnDocument = ReturnDocument.After
            });
        }

        /// <summary>
        /// Processes the tribe file
        /// </summary>
        private async Task ProcessPlayerFile(Stream f)
        {
            //Open inline file
            var indes = new ArkSaveEditor.Deserializer.Inline.InlineFileDeserializer();
            var source = indes.ReadInlineFile(f);

            //Grab tribe player struct.
            InlineStructProperty playerDataStruct = (InlineStructProperty)source.props.Find(x => x.name.CompareNameTo("MyData"));
            ArkStructInlineProps playerData = (ArkStructInlineProps)playerDataStruct.data;

            //Grab data
            DbPlayerProfile output = new DbPlayerProfile
            {
                revision_id = revision_id,
                server_id = id,
            };

            //Read basics
            output.name = ((InlineStrProperty)playerData.props.Find(x => x.name.CompareNameTo("PlayerName"))).value;
            output.ark_id = ((InlineUInt64Property)playerData.props.Find(x => x.name.CompareNameTo("PlayerDataID"))).value;

            //Steam ID is read below
            output.tribe_id = -1;
            try
            {
                output.tribe_id = ((InlineIntProperty)playerData.props.Find(x => x.name.CompareNameTo("TribeID"))).value;
            }
            catch { }

            //in-game name is read below
            InlineStructProperty playerStats = (InlineStructProperty)(playerData.props.Where(x => x.name.CompareNameTo("MyPlayerCharacterConfig")).ToArray()[0]);
            output.ig_name = ((InlineStrProperty)(((ArkStructInlineProps)playerStats.data).props.Where(x => x.name.CompareNameTo("PlayerCharacterName")).ToArray()[0])).value;

            //Read Steam ID
            InlineStructProperty steamStruct = (InlineStructProperty)playerData.props.Find(x => x.name.CompareNameTo("UniqueID"));
            ArkStructUniqueNetId steamData = (ArkStructUniqueNetId)steamStruct.data;
            output.steam_id = steamData.netId;

            //Close
            f.Close();
            f.Dispose();

            //Update or insert
            var filterBuilder = Builders<DbPlayerProfile>.Filter;
            var filter = filterBuilder.Eq("server_id", id) & filterBuilder.Eq("steam_id", output.steam_id);
            await Program.conn.content_player_profiles.FindOneAndReplaceAsync<DbPlayerProfile>(filter, output, new FindOneAndReplaceOptions<DbPlayerProfile, DbPlayerProfile>
            {
                IsUpsert = true,
                ReturnDocument = ReturnDocument.After
            });
        }

        /// <summary>
        /// Helper class
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private InlineProperty InlineGetPropertyByName(string name, InlineStructProperty.ArkStructInlineProps container)
        {
            var data = container.props.Where(x => x.name.CompareNameTo(name)).ToArray();
            if (data.Length == 1)
                return data[0];
            return null;
        }

        /// <summary>
        /// Used when a dino is found when processing data.
        /// </summary>
        private void ProcessDino(DotArkGameObject obj, List<DotArkProperty> props, object deserBase)
        {
            ArkSaveEditor.Deserializer.DotArk.DotArkDeserializer deser = (ArkSaveEditor.Deserializer.DotArk.DotArkDeserializer)deserBase;
            ArkPropertyReader reader = new ArkPropertyReader(props);
            bool tamed = reader.CheckIfValueExists("TamedName") && reader.CheckIfValueExists("TribeName") && reader.CheckIfValueExists("TargetingTeam");
            if (!tamed)
                return;

            //Get the referenced status and open a reader on it
            var statusComponent = reader.GetGameObjectRef("MyCharacterStatusComponent");
            var statusComponentReader = new ArkPropertyReader(statusComponent.ReadPropsFromFile(deser));

            //Read properties
            DbDino db = new DbDino
            {
                is_tamed = tamed,
                is_female = reader.GetBooleanProperty("bIsFemale"),
                server_id = id,
                tribe_id = -1,
                classname = obj.classname.classname,
                location = new DbLocation
                {
                    x = obj.locationData.x,
                    y = obj.locationData.y,
                    z = obj.locationData.z,
                    pitch = obj.locationData.pitch,
                    yaw = obj.locationData.yaw,
                    roll = obj.locationData.roll,
                },
                revision_id = revision_id
            };

            //Convert the colors into a byte array and hex.
            var colorAttrib = reader.GetPropertiesByName("ColorSetIndices"); //Get all of the color properties from the dinosaur. These are indexes in the color table.
            byte[] colors = new byte[colorAttrib.Length]; //Initialize the array for storing the indexes. These will be saved to the file.
            db.colors = new string[colorAttrib.Length]; //Initialize the array for reading nice HTML color values.
            for (int i = 0; i < colors.Length; i++) //For each color region this dinosaur has. Each "ColorSetIndices" value is a color region.
            {
                colors[i] = ((ByteProperty)colorAttrib[i]).byteValue; //Get the index in the color table by getting the byte value out of the property
                //Validate that the color is in range
                byte color = colors[i];
                if (color <= 0 || color > ArkColorIds.ARK_COLOR_IDS.Length)
                    db.colors[i] = "#FFF";
                else
                    db.colors[i] = ArkColorIds.ARK_COLOR_IDS[colors[i] - 1]; //Look this up in the color table to get the nice HTML value.
            }

            //Read the dinosaur ID by combining the the bytes of the two UInt32 values.
            byte[] buf = new byte[8];
            BitConverter.GetBytes(reader.GetUInt32Property("DinoID1")).CopyTo(buf, 0);
            BitConverter.GetBytes(reader.GetUInt32Property("DinoID2")).CopyTo(buf, 4);
            //Convert this to a ulong
            db.dino_id = BitConverter.ToUInt64(buf, 0);

            //Read stats
            db.current_stats = ArkDinosaurStatHelper.ReadStats(statusComponentReader, "CurrentStatusValues", false);
            db.base_levelups_applied = ArkDinosaurStatHelper.ReadStats(statusComponentReader, "NumberOfLevelUpPointsApplied", true);
            db.base_level = 1;
            if (statusComponentReader.CheckIfValueExists("BaseCharacterLevel"))
                db.base_level = statusComponentReader.GetInt32Property("BaseCharacterLevel");
            db.level = db.base_level;
            db.tamed_levelups_applied = new DbArkDinosaurStats();

            //Now, convert attributes that only exist on tamed dinosaurs.
            if (db.is_tamed)
            {
                db.tamed_name = reader.GetStringProperty("TamedName");
                db.tribe_id = reader.GetInt32Property("TargetingTeam");
                db.tamer_name = reader.GetStringProperty("TribeName");
                db.tamed_levelups_applied = ArkDinosaurStatHelper.ReadStats(statusComponentReader, "NumberOfLevelUpPointsAppliedTamed", true);
                if (statusComponentReader.CheckIfValueExists("ExtraCharacterLevel"))
                    db.level += statusComponentReader.GetUInt16Property("ExtraCharacterLevel");
                if (statusComponentReader.HasProperty("ExperiencePoints"))
                    db.experience = statusComponentReader.GetFloatProperty("ExperiencePoints");
                else
                    db.experience = 0;

                db.is_baby = reader.GetBooleanProperty("bIsBaby");
                if (db.is_baby)
                {
                    db.baby_age = reader.GetFloatProperty("BabyAge");
                    db.next_imprint_time = -1;
                    if (reader.HasProperty("BabyNextCuddleTime"))
                        db.next_imprint_time = reader.GetDoubleProperty("BabyNextCuddleTime");
                    if (statusComponentReader.HasProperty("DinoImprintingQuality"))
                        db.imprint_quality = statusComponentReader.GetFloatProperty("DinoImprintingQuality");
                    else
                        db.imprint_quality = 0;
                }
            }

            //Update or insert
            var filterBuilder = Builders<DbDino>.Filter;
            var filter = filterBuilder.Eq("server_id", id) & filterBuilder.Eq("tribe_id", db.tribe_id) & filterBuilder.Eq("dino_id", db.dino_id);
            var response = Program.conn.content_dinos.FindOneAndReplace<DbDino>(filter, db, new FindOneAndReplaceOptions<DbDino, DbDino>
            {
                IsUpsert = true,
                ReturnDocument = ReturnDocument.After
            });

            //Now, insert items
            if(reader.HasProperty("MyInventoryComponent"))
            {
                //Get the referenced inventory and open a reader on it
                var inventoryComponent = reader.GetGameObjectRef("MyInventoryComponent");
                var inventoryComponentReader = new ArkPropertyReader(inventoryComponent.ReadPropsFromFile(deser));

                //Upload all
                ArkInventoryReader.SaveInventory(inventoryComponent, inventoryComponentReader, deser, response._id, DbInventoryParentType.Dino, db.tribe_id, id, revision_id);
            }
        }
    }
}
